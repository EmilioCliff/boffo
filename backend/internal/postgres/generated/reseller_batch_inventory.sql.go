// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reseller_batch_inventory.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createResellerBatchInventoryRecord = `-- name: CreateResellerBatchInventoryRecord :one
INSERT INTO reseller_batch_inventory (
          reseller_id,
          product_id,
          source_batch_id,
          batch_number,
          remaining_quantity,
          unit_cost
      )
VALUES  ($1, $2, $3, $4, $5, $6)
RETURNING id, reseller_id, product_id, source_batch_id, batch_number, unit_cost, remaining_quantity, created_at
`

type CreateResellerBatchInventoryRecordParams struct {
	ResellerID        int64          `json:"reseller_id"`
	ProductID         int64          `json:"product_id"`
	SourceBatchID     int64          `json:"source_batch_id"`
	BatchNumber       string         `json:"batch_number"`
	RemainingQuantity int64          `json:"remaining_quantity"`
	UnitCost          pgtype.Numeric `json:"unit_cost"`
}

func (q *Queries) CreateResellerBatchInventoryRecord(ctx context.Context, arg CreateResellerBatchInventoryRecordParams) (ResellerBatchInventory, error) {
	row := q.db.QueryRow(ctx, createResellerBatchInventoryRecord,
		arg.ResellerID,
		arg.ProductID,
		arg.SourceBatchID,
		arg.BatchNumber,
		arg.RemainingQuantity,
		arg.UnitCost,
	)
	var i ResellerBatchInventory
	err := row.Scan(
		&i.ID,
		&i.ResellerID,
		&i.ProductID,
		&i.SourceBatchID,
		&i.BatchNumber,
		&i.UnitCost,
		&i.RemainingQuantity,
		&i.CreatedAt,
	)
	return i, err
}

const getResellerBatchInventoryProductSum = `-- name: GetResellerBatchInventoryProductSum :one
SELECT COALESCE(SUM(remaining_quantity), 0)::bigint AS total_remaining
FROM reseller_batch_inventory
WHERE reseller_id = $1
      AND product_id = $2
      AND remaining_quantity > 0
`

type GetResellerBatchInventoryProductSumParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
}

func (q *Queries) GetResellerBatchInventoryProductSum(ctx context.Context, arg GetResellerBatchInventoryProductSumParams) (int64, error) {
	row := q.db.QueryRow(ctx, getResellerBatchInventoryProductSum, arg.ResellerID, arg.ProductID)
	var total_remaining int64
	err := row.Scan(&total_remaining)
	return total_remaining, err
}

const listResellerBatchInventoryForUpdate = `-- name: ListResellerBatchInventoryForUpdate :many
SELECT rbi.id, rbi.reseller_id, rbi.product_id, rbi.source_batch_id, rbi.batch_number, rbi.unit_cost, rbi.remaining_quantity, rbi.created_at, pb.batch_number
FROM reseller_batch_inventory rbi
JOIN product_batches pb ON pb.id = rbi.source_batch_id
WHERE 
    rbi.reseller_id = $1
    AND rbi.product_id = $2
    AND rbi.remaining_quantity > 0
ORDER BY pb.date_received ASC
FOR UPDATE
`

type ListResellerBatchInventoryForUpdateParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
}

type ListResellerBatchInventoryForUpdateRow struct {
	ID                int64          `json:"id"`
	ResellerID        int64          `json:"reseller_id"`
	ProductID         int64          `json:"product_id"`
	SourceBatchID     int64          `json:"source_batch_id"`
	BatchNumber       string         `json:"batch_number"`
	UnitCost          pgtype.Numeric `json:"unit_cost"`
	RemainingQuantity int64          `json:"remaining_quantity"`
	CreatedAt         time.Time      `json:"created_at"`
	BatchNumber_2     string         `json:"batch_number_2"`
}

func (q *Queries) ListResellerBatchInventoryForUpdate(ctx context.Context, arg ListResellerBatchInventoryForUpdateParams) ([]ListResellerBatchInventoryForUpdateRow, error) {
	rows, err := q.db.Query(ctx, listResellerBatchInventoryForUpdate, arg.ResellerID, arg.ProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListResellerBatchInventoryForUpdateRow{}
	for rows.Next() {
		var i ListResellerBatchInventoryForUpdateRow
		if err := rows.Scan(
			&i.ID,
			&i.ResellerID,
			&i.ProductID,
			&i.SourceBatchID,
			&i.BatchNumber,
			&i.UnitCost,
			&i.RemainingQuantity,
			&i.CreatedAt,
			&i.BatchNumber_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeResellerBatchInventoryQuantity = `-- name: RemoveResellerBatchInventoryQuantity :one
UPDATE reseller_batch_inventory
SET remaining_quantity = remaining_quantity - $1
WHERE id = $2
  AND remaining_quantity >= $1
RETURNING id, reseller_id, product_id, source_batch_id, batch_number, unit_cost, remaining_quantity, created_at
`

type RemoveResellerBatchInventoryQuantityParams struct {
	Quantity    int64 `json:"quantity"`
	InventoryID int64 `json:"inventory_id"`
}

func (q *Queries) RemoveResellerBatchInventoryQuantity(ctx context.Context, arg RemoveResellerBatchInventoryQuantityParams) (ResellerBatchInventory, error) {
	row := q.db.QueryRow(ctx, removeResellerBatchInventoryQuantity, arg.Quantity, arg.InventoryID)
	var i ResellerBatchInventory
	err := row.Scan(
		&i.ID,
		&i.ResellerID,
		&i.ProductID,
		&i.SourceBatchID,
		&i.BatchNumber,
		&i.UnitCost,
		&i.RemainingQuantity,
		&i.CreatedAt,
	)
	return i, err
}
