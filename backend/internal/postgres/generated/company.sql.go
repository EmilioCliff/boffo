// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: company.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCompanyStock = `-- name: AddCompanyStock :one
UPDATE company_stock
SET quantity = quantity + $1
WHERE product_id = $2
RETURNING product_id, quantity
`

type AddCompanyStockParams struct {
	Quantity  int64 `json:"quantity"`
	ProductID int64 `json:"product_id"`
}

func (q *Queries) AddCompanyStock(ctx context.Context, arg AddCompanyStockParams) (CompanyStock, error) {
	row := q.db.QueryRow(ctx, addCompanyStock, arg.Quantity, arg.ProductID)
	var i CompanyStock
	err := row.Scan(&i.ProductID, &i.Quantity)
	return i, err
}

const createCompanyStock = `-- name: CreateCompanyStock :one
INSERT INTO company_stock (product_id)
VALUES ($1)
RETURNING product_id, quantity
`

func (q *Queries) CreateCompanyStock(ctx context.Context, productID int64) (CompanyStock, error) {
	row := q.db.QueryRow(ctx, createCompanyStock, productID)
	var i CompanyStock
	err := row.Scan(&i.ProductID, &i.Quantity)
	return i, err
}

const listCompanyStock = `-- name: ListCompanyStock :many
SELECT
    p.id AS product_id,
    p.name,
    p.category,
    p.unit,
    p.price,
    p.low_stock_threshold,
    p.description,
    cs.quantity AS company_quantity
FROM company_stock cs
JOIN products p ON p.id = cs.product_id
WHERE 
    (
        COALESCE($1, '') = '' 
        OR LOWER(p.name) LIKE $1
        OR LOWER(p.category) LIKE $1
    )
    AND (
        $2::boolean IS NULL
        OR ($2 = true AND cs.quantity > 0)
        OR ($2 = false AND cs.quantity = 0)
    )
    AND p.deleted = false
ORDER BY p.name
LIMIT $4 OFFSET $3
`

type ListCompanyStockParams struct {
	Search  interface{} `json:"search"`
	InStock pgtype.Bool `json:"in_stock"`
	Offset  int32       `json:"offset"`
	Limit   int32       `json:"limit"`
}

type ListCompanyStockRow struct {
	ProductID         int64          `json:"product_id"`
	Name              string         `json:"name"`
	Category          string         `json:"category"`
	Unit              string         `json:"unit"`
	Price             pgtype.Numeric `json:"price"`
	LowStockThreshold int32          `json:"low_stock_threshold"`
	Description       pgtype.Text    `json:"description"`
	CompanyQuantity   int64          `json:"company_quantity"`
}

func (q *Queries) ListCompanyStock(ctx context.Context, arg ListCompanyStockParams) ([]ListCompanyStockRow, error) {
	rows, err := q.db.Query(ctx, listCompanyStock,
		arg.Search,
		arg.InStock,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCompanyStockRow{}
	for rows.Next() {
		var i ListCompanyStockRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Category,
			&i.Unit,
			&i.Price,
			&i.LowStockThreshold,
			&i.Description,
			&i.CompanyQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompanyStockCount = `-- name: ListCompanyStockCount :one
SELECT COUNT(*) AS total_items
FROM company_stock cs
JOIN products p ON p.id = cs.product_id
WHERE 
    (
        COALESCE($1, '') = '' 
        OR LOWER(p.name) LIKE $1
        OR LOWER(p.category) LIKE $1
    )
    AND (
        $2::boolean IS NULL
        OR ($2 = true AND cs.quantity > 0)
        OR ($2 = false AND cs.quantity = 0)
    )
    AND p.deleted = false
`

type ListCompanyStockCountParams struct {
	Search  interface{} `json:"search"`
	InStock pgtype.Bool `json:"in_stock"`
}

func (q *Queries) ListCompanyStockCount(ctx context.Context, arg ListCompanyStockCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listCompanyStockCount, arg.Search, arg.InStock)
	var total_items int64
	err := row.Scan(&total_items)
	return total_items, err
}

const removeCompanyStock = `-- name: RemoveCompanyStock :one
UPDATE company_stock
SET quantity = quantity - $1
WHERE product_id = $2 AND quantity >= $1
RETURNING product_id, quantity
`

type RemoveCompanyStockParams struct {
	Quantity  int64 `json:"quantity"`
	ProductID int64 `json:"product_id"`
}

func (q *Queries) RemoveCompanyStock(ctx context.Context, arg RemoveCompanyStockParams) (CompanyStock, error) {
	row := q.db.QueryRow(ctx, removeCompanyStock, arg.Quantity, arg.ProductID)
	var i CompanyStock
	err := row.Scan(&i.ProductID, &i.Quantity)
	return i, err
}
