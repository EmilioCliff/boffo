// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: batch_inventory.sql

package generated

import (
	"context"
	"time"
)

const addBatchInventoryQuantity = `-- name: AddBatchInventoryQuantity :one
UPDATE batch_inventory
SET remaining_quantity = remaining_quantity + $1
WHERE batch_id = $2 AND product_id = $3
RETURNING batch_id, product_id, remaining_quantity, created_at
`

type AddBatchInventoryQuantityParams struct {
	Quantity  int64 `json:"quantity"`
	BatchID   int64 `json:"batch_id"`
	ProductID int64 `json:"product_id"`
}

func (q *Queries) AddBatchInventoryQuantity(ctx context.Context, arg AddBatchInventoryQuantityParams) (BatchInventory, error) {
	row := q.db.QueryRow(ctx, addBatchInventoryQuantity, arg.Quantity, arg.BatchID, arg.ProductID)
	var i BatchInventory
	err := row.Scan(
		&i.BatchID,
		&i.ProductID,
		&i.RemainingQuantity,
		&i.CreatedAt,
	)
	return i, err
}

const createBatchInventoryRecord = `-- name: CreateBatchInventoryRecord :one
INSERT INTO batch_inventory (batch_id, product_id, remaining_quantity)
VALUES ($1, $2, $3)
RETURNING batch_id, product_id, remaining_quantity, created_at
`

type CreateBatchInventoryRecordParams struct {
	BatchID           int64 `json:"batch_id"`
	ProductID         int64 `json:"product_id"`
	RemainingQuantity int64 `json:"remaining_quantity"`
}

func (q *Queries) CreateBatchInventoryRecord(ctx context.Context, arg CreateBatchInventoryRecordParams) (BatchInventory, error) {
	row := q.db.QueryRow(ctx, createBatchInventoryRecord, arg.BatchID, arg.ProductID, arg.RemainingQuantity)
	var i BatchInventory
	err := row.Scan(
		&i.BatchID,
		&i.ProductID,
		&i.RemainingQuantity,
		&i.CreatedAt,
	)
	return i, err
}

const getBatchInventoryProductSum = `-- name: GetBatchInventoryProductSum :one
SELECT COALESCE(SUM(remaining_quantity), 0)::bigint AS total_remaining
FROM batch_inventory
WHERE product_id = $1
      AND remaining_quantity > 0
`

func (q *Queries) GetBatchInventoryProductSum(ctx context.Context, productID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getBatchInventoryProductSum, productID)
	var total_remaining int64
	err := row.Scan(&total_remaining)
	return total_remaining, err
}

const listBatchInventoryForUpdate = `-- name: ListBatchInventoryForUpdate :many
SELECT 
    bi.batch_id, bi.product_id, bi.remaining_quantity, bi.created_at,
    pb.batch_number
FROM batch_inventory bi
JOIN product_batches pb ON pb.id = bi.batch_id
WHERE 
    bi.product_id = $1
    AND bi.remaining_quantity > 0
ORDER BY pb.date_received ASC
FOR UPDATE
`

type ListBatchInventoryForUpdateRow struct {
	BatchID           int64     `json:"batch_id"`
	ProductID         int64     `json:"product_id"`
	RemainingQuantity int64     `json:"remaining_quantity"`
	CreatedAt         time.Time `json:"created_at"`
	BatchNumber       string    `json:"batch_number"`
}

func (q *Queries) ListBatchInventoryForUpdate(ctx context.Context, productID int64) ([]ListBatchInventoryForUpdateRow, error) {
	rows, err := q.db.Query(ctx, listBatchInventoryForUpdate, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBatchInventoryForUpdateRow{}
	for rows.Next() {
		var i ListBatchInventoryForUpdateRow
		if err := rows.Scan(
			&i.BatchID,
			&i.ProductID,
			&i.RemainingQuantity,
			&i.CreatedAt,
			&i.BatchNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeBatchInventoryQuantity = `-- name: RemoveBatchInventoryQuantity :one
UPDATE batch_inventory
SET remaining_quantity = remaining_quantity - $1
WHERE batch_id = $2 AND product_id = $3 AND remaining_quantity >= $1
RETURNING batch_id, product_id, remaining_quantity, created_at
`

type RemoveBatchInventoryQuantityParams struct {
	Quantity  int64 `json:"quantity"`
	BatchID   int64 `json:"batch_id"`
	ProductID int64 `json:"product_id"`
}

func (q *Queries) RemoveBatchInventoryQuantity(ctx context.Context, arg RemoveBatchInventoryQuantityParams) (BatchInventory, error) {
	row := q.db.QueryRow(ctx, removeBatchInventoryQuantity, arg.Quantity, arg.BatchID, arg.ProductID)
	var i BatchInventory
	err := row.Scan(
		&i.BatchID,
		&i.ProductID,
		&i.RemainingQuantity,
		&i.CreatedAt,
	)
	return i, err
}
