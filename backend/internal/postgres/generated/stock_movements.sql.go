// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stock_movements.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createStockMovementRecord = `-- name: CreateStockMovementRecord :one
INSERT INTO stock_movements (product_id, owner_type, owner_id, movement_type, quantity, unit_price, source, note)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, product_id, owner_type, owner_id, movement_type, quantity, unit_price, source, note, created_at
`

type CreateStockMovementRecordParams struct {
	ProductID    int64          `json:"product_id"`
	OwnerType    string         `json:"owner_type"`
	OwnerID      pgtype.Int8    `json:"owner_id"`
	MovementType string         `json:"movement_type"`
	Quantity     int64          `json:"quantity"`
	UnitPrice    pgtype.Numeric `json:"unit_price"`
	Source       string         `json:"source"`
	Note         string         `json:"note"`
}

func (q *Queries) CreateStockMovementRecord(ctx context.Context, arg CreateStockMovementRecordParams) (StockMovement, error) {
	row := q.db.QueryRow(ctx, createStockMovementRecord,
		arg.ProductID,
		arg.OwnerType,
		arg.OwnerID,
		arg.MovementType,
		arg.Quantity,
		arg.UnitPrice,
		arg.Source,
		arg.Note,
	)
	var i StockMovement
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OwnerType,
		&i.OwnerID,
		&i.MovementType,
		&i.Quantity,
		&i.UnitPrice,
		&i.Source,
		&i.Note,
		&i.CreatedAt,
	)
	return i, err
}

const listStockMovements = `-- name: ListStockMovements :many
SELECT sm.id, sm.product_id, sm.owner_type, sm.owner_id, sm.movement_type, sm.quantity, sm.unit_price, sm.source, sm.note, sm.created_at, p.name AS product_name, p.unit AS product_unit, p.category AS product_category,
    u.name AS owner_name, u.phone_number AS owner_phone_number
FROM stock_movements sm
LEFT JOIN products p ON p.id = sm.product_id
LEFT JOIN users u ON u.id = sm.owner_id AND sm.owner_type = 'RESELLER'
WHERE 
    (
        $1::text IS NULL
        OR sm.owner_type = $1
    )
    AND (
        $2::bigint IS NULL
        OR sm.owner_id = $2
    )
    AND (
        $3::bigint IS NULL
        OR sm.product_id = $3
    )
    AND (
        $4::text IS NULL
        OR sm.movement_type = $4
    )
    AND (
        $5::text IS NULL
        OR sm.source = $5
    )
ORDER BY sm.created_at DESC
LIMIT $7 OFFSET $6
`

type ListStockMovementsParams struct {
	OwnerType    pgtype.Text `json:"owner_type"`
	OwnerID      pgtype.Int8 `json:"owner_id"`
	ProductID    pgtype.Int8 `json:"product_id"`
	MovementType pgtype.Text `json:"movement_type"`
	Source       pgtype.Text `json:"source"`
	Offset       int32       `json:"offset"`
	Limit        int32       `json:"limit"`
}

type ListStockMovementsRow struct {
	ID               int64          `json:"id"`
	ProductID        int64          `json:"product_id"`
	OwnerType        string         `json:"owner_type"`
	OwnerID          pgtype.Int8    `json:"owner_id"`
	MovementType     string         `json:"movement_type"`
	Quantity         int64          `json:"quantity"`
	UnitPrice        pgtype.Numeric `json:"unit_price"`
	Source           string         `json:"source"`
	Note             string         `json:"note"`
	CreatedAt        time.Time      `json:"created_at"`
	ProductName      pgtype.Text    `json:"product_name"`
	ProductUnit      pgtype.Text    `json:"product_unit"`
	ProductCategory  pgtype.Text    `json:"product_category"`
	OwnerName        pgtype.Text    `json:"owner_name"`
	OwnerPhoneNumber pgtype.Text    `json:"owner_phone_number"`
}

func (q *Queries) ListStockMovements(ctx context.Context, arg ListStockMovementsParams) ([]ListStockMovementsRow, error) {
	rows, err := q.db.Query(ctx, listStockMovements,
		arg.OwnerType,
		arg.OwnerID,
		arg.ProductID,
		arg.MovementType,
		arg.Source,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStockMovementsRow{}
	for rows.Next() {
		var i ListStockMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.OwnerType,
			&i.OwnerID,
			&i.MovementType,
			&i.Quantity,
			&i.UnitPrice,
			&i.Source,
			&i.Note,
			&i.CreatedAt,
			&i.ProductName,
			&i.ProductUnit,
			&i.ProductCategory,
			&i.OwnerName,
			&i.OwnerPhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockMovementsCount = `-- name: ListStockMovementsCount :one
SELECT COUNT(*) AS total_movements
FROM stock_movements sm
WHERE 
    (
        $1::text IS NULL
        OR sm.owner_type = $1
    )
    AND (
        $2::bigint IS NULL
        OR sm.owner_id = $2
    )
    AND (
        $3::bigint IS NULL
        OR sm.product_id = $3
    )
    AND (
        $4::text IS NULL
        OR sm.movement_type = $4
    )
    AND (
        $5::text IS NULL
        OR sm.source = $5
    )
`

type ListStockMovementsCountParams struct {
	OwnerType    pgtype.Text `json:"owner_type"`
	OwnerID      pgtype.Int8 `json:"owner_id"`
	ProductID    pgtype.Int8 `json:"product_id"`
	MovementType pgtype.Text `json:"movement_type"`
	Source       pgtype.Text `json:"source"`
}

func (q *Queries) ListStockMovementsCount(ctx context.Context, arg ListStockMovementsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listStockMovementsCount,
		arg.OwnerType,
		arg.OwnerID,
		arg.ProductID,
		arg.MovementType,
		arg.Source,
	)
	var total_movements int64
	err := row.Scan(&total_movements)
	return total_movements, err
}
