// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: resellers.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addResellerStockQuantity = `-- name: AddResellerStockQuantity :one
UPDATE reseller_stock
SET quantity = quantity + $3
WHERE reseller_id = $1 AND product_id = $2
RETURNING reseller_id, product_id, quantity, low_stock_threshold
`

type AddResellerStockQuantityParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
	Quantity   int64 `json:"quantity"`
}

func (q *Queries) AddResellerStockQuantity(ctx context.Context, arg AddResellerStockQuantityParams) (ResellerStock, error) {
	row := q.db.QueryRow(ctx, addResellerStockQuantity, arg.ResellerID, arg.ProductID, arg.Quantity)
	var i ResellerStock
	err := row.Scan(
		&i.ResellerID,
		&i.ProductID,
		&i.Quantity,
		&i.LowStockThreshold,
	)
	return i, err
}

const checkResellerStockExists = `-- name: CheckResellerStockExists :one
SELECT EXISTS (
    SELECT 1 FROM reseller_stock
    WHERE reseller_id = $1 AND product_id = $2
)
`

type CheckResellerStockExistsParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
}

func (q *Queries) CheckResellerStockExists(ctx context.Context, arg CheckResellerStockExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkResellerStockExists, arg.ResellerID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createResellerAccount = `-- name: CreateResellerAccount :one
INSERT INTO reseller_accounts (reseller_id)
VALUES ($1)
RETURNING reseller_id, total_stock_received, total_value_received, total_sales_value, total_paid, total_cogs, balance
`

func (q *Queries) CreateResellerAccount(ctx context.Context, resellerID int64) (ResellerAccount, error) {
	row := q.db.QueryRow(ctx, createResellerAccount, resellerID)
	var i ResellerAccount
	err := row.Scan(
		&i.ResellerID,
		&i.TotalStockReceived,
		&i.TotalValueReceived,
		&i.TotalSalesValue,
		&i.TotalPaid,
		&i.TotalCogs,
		&i.Balance,
	)
	return i, err
}

const createResellerStock = `-- name: CreateResellerStock :one
INSERT INTO reseller_stock (reseller_id, product_id, quantity)
VALUES ($1, $2, $3)
RETURNING reseller_id, product_id, quantity, low_stock_threshold
`

type CreateResellerStockParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
	Quantity   int64 `json:"quantity"`
}

func (q *Queries) CreateResellerStock(ctx context.Context, arg CreateResellerStockParams) (ResellerStock, error) {
	row := q.db.QueryRow(ctx, createResellerStock, arg.ResellerID, arg.ProductID, arg.Quantity)
	var i ResellerStock
	err := row.Scan(
		&i.ResellerID,
		&i.ProductID,
		&i.Quantity,
		&i.LowStockThreshold,
	)
	return i, err
}

const getResellerAccount = `-- name: GetResellerAccount :one
SELECT reseller_id, total_stock_received, total_value_received, total_sales_value, total_paid, total_cogs, balance FROM reseller_accounts
WHERE reseller_id = $1
`

func (q *Queries) GetResellerAccount(ctx context.Context, resellerID int64) (ResellerAccount, error) {
	row := q.db.QueryRow(ctx, getResellerAccount, resellerID)
	var i ResellerAccount
	err := row.Scan(
		&i.ResellerID,
		&i.TotalStockReceived,
		&i.TotalValueReceived,
		&i.TotalSalesValue,
		&i.TotalPaid,
		&i.TotalCogs,
		&i.Balance,
	)
	return i, err
}

const getResellerWithAccountByID = `-- name: GetResellerWithAccountByID :one
SELECT u.id, u.name, u.email, u.phone_number, u.role, u.password, u.refresh_token, u.deleted, u.created_at, ra.reseller_id, ra.total_stock_received, ra.total_value_received, ra.total_sales_value, ra.total_paid, ra.total_cogs, ra.balance
FROM users u
JOIN reseller_accounts ra ON ra.reseller_id = u.id
WHERE 
    role = 'staff' AND deleted = false
    AND u.id = $1
`

type GetResellerWithAccountByIDRow struct {
	ID                 int64          `json:"id"`
	Name               string         `json:"name"`
	Email              string         `json:"email"`
	PhoneNumber        string         `json:"phone_number"`
	Role               string         `json:"role"`
	Password           string         `json:"password"`
	RefreshToken       pgtype.Text    `json:"refresh_token"`
	Deleted            bool           `json:"deleted"`
	CreatedAt          time.Time      `json:"created_at"`
	ResellerID         int64          `json:"reseller_id"`
	TotalStockReceived int64          `json:"total_stock_received"`
	TotalValueReceived pgtype.Numeric `json:"total_value_received"`
	TotalSalesValue    pgtype.Numeric `json:"total_sales_value"`
	TotalPaid          pgtype.Numeric `json:"total_paid"`
	TotalCogs          pgtype.Numeric `json:"total_cogs"`
	Balance            pgtype.Numeric `json:"balance"`
}

func (q *Queries) GetResellerWithAccountByID(ctx context.Context, resellerID int64) (GetResellerWithAccountByIDRow, error) {
	row := q.db.QueryRow(ctx, getResellerWithAccountByID, resellerID)
	var i GetResellerWithAccountByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PhoneNumber,
		&i.Role,
		&i.Password,
		&i.RefreshToken,
		&i.Deleted,
		&i.CreatedAt,
		&i.ResellerID,
		&i.TotalStockReceived,
		&i.TotalValueReceived,
		&i.TotalSalesValue,
		&i.TotalPaid,
		&i.TotalCogs,
		&i.Balance,
	)
	return i, err
}

const listResellerStock = `-- name: ListResellerStock :many
SELECT 
    rs.reseller_id, rs.product_id, rs.quantity, rs.low_stock_threshold, 
    p.id AS product_id,
    p.name,
    p.category,
    p.unit,
    p.price,
    p.low_stock_threshold
FROM reseller_stock rs
JOIN products p ON p.id = rs.product_id
WHERE 
    (
        COALESCE($1, '') = '' 
        OR LOWER(p.name) LIKE $1
        OR LOWER(p.category) LIKE $1
    )
     AND (
        $2::boolean IS NULL
        OR ($2 = true AND rs.quantity > 0)
        OR ($2 = false AND rs.quantity = 0)
    )
    AND (
        $3::bigint IS NULL
        OR rs.reseller_id = $3::bigint
    )
    -- AND rs.reseller_id = sqlc.arg('reseller_id')
ORDER BY p.name
LIMIT $5 OFFSET $4
`

type ListResellerStockParams struct {
	Search     interface{} `json:"search"`
	InStock    pgtype.Bool `json:"in_stock"`
	ResellerID pgtype.Int8 `json:"reseller_id"`
	Offset     int32       `json:"offset"`
	Limit      int32       `json:"limit"`
}

type ListResellerStockRow struct {
	ResellerID          int64          `json:"reseller_id"`
	ProductID           int64          `json:"product_id"`
	Quantity            int64          `json:"quantity"`
	LowStockThreshold   int32          `json:"low_stock_threshold"`
	ProductID_2         int64          `json:"product_id_2"`
	Name                string         `json:"name"`
	Category            string         `json:"category"`
	Unit                string         `json:"unit"`
	Price               pgtype.Numeric `json:"price"`
	LowStockThreshold_2 int32          `json:"low_stock_threshold_2"`
}

func (q *Queries) ListResellerStock(ctx context.Context, arg ListResellerStockParams) ([]ListResellerStockRow, error) {
	rows, err := q.db.Query(ctx, listResellerStock,
		arg.Search,
		arg.InStock,
		arg.ResellerID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListResellerStockRow{}
	for rows.Next() {
		var i ListResellerStockRow
		if err := rows.Scan(
			&i.ResellerID,
			&i.ProductID,
			&i.Quantity,
			&i.LowStockThreshold,
			&i.ProductID_2,
			&i.Name,
			&i.Category,
			&i.Unit,
			&i.Price,
			&i.LowStockThreshold_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResellerStockCount = `-- name: ListResellerStockCount :one
SELECT COUNT(*) AS total_items
FROM reseller_stock rs
JOIN products p ON p.id = rs.product_id
WHERE 
    (
        COALESCE($1, '') = '' 
        OR LOWER(p.name) LIKE $1
        OR LOWER(p.category) LIKE $1
    )
     AND (
        $2::boolean IS NULL
        OR ($2 = true AND rs.quantity > 0)
        OR ($2 = false AND rs.quantity = 0)
    )
    AND (
        $3::bigint IS NULL
        OR rs.reseller_id = $3::bigint
    )
`

type ListResellerStockCountParams struct {
	Search     interface{} `json:"search"`
	InStock    pgtype.Bool `json:"in_stock"`
	ResellerID pgtype.Int8 `json:"reseller_id"`
}

func (q *Queries) ListResellerStockCount(ctx context.Context, arg ListResellerStockCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listResellerStockCount, arg.Search, arg.InStock, arg.ResellerID)
	var total_items int64
	err := row.Scan(&total_items)
	return total_items, err
}

const listResellersWithAccount = `-- name: ListResellersWithAccount :many
SELECT u.id as user_id, u.name, u.phone_number, u.email, ra.reseller_id, ra.total_stock_received, ra.total_value_received, ra.total_sales_value, ra.total_paid, ra.total_cogs, ra.balance,
       COALESCE((SELECT SUM(quantity) FROM reseller_stock WHERE reseller_id = u.id), 0)::bigint AS current_stock_units
FROM users u
JOIN reseller_accounts ra ON ra.reseller_id = u.id
WHERE 
    role = 'staff' AND deleted = false
    AND (
        COALESCE($1, '') = '' 
        OR LOWER(u.name) LIKE $1
        OR LOWER(u.phone_number) LIKE $1
         OR LOWER(u.email) LIKE $1
    )
ORDER BY u.created_at DESC
LIMIT $3 OFFSET $2
`

type ListResellersWithAccountParams struct {
	Search interface{} `json:"search"`
	Offset int32       `json:"offset"`
	Limit  int32       `json:"limit"`
}

type ListResellersWithAccountRow struct {
	UserID             int64          `json:"user_id"`
	Name               string         `json:"name"`
	PhoneNumber        string         `json:"phone_number"`
	Email              string         `json:"email"`
	ResellerID         int64          `json:"reseller_id"`
	TotalStockReceived int64          `json:"total_stock_received"`
	TotalValueReceived pgtype.Numeric `json:"total_value_received"`
	TotalSalesValue    pgtype.Numeric `json:"total_sales_value"`
	TotalPaid          pgtype.Numeric `json:"total_paid"`
	TotalCogs          pgtype.Numeric `json:"total_cogs"`
	Balance            pgtype.Numeric `json:"balance"`
	CurrentStockUnits  int64          `json:"current_stock_units"`
}

func (q *Queries) ListResellersWithAccount(ctx context.Context, arg ListResellersWithAccountParams) ([]ListResellersWithAccountRow, error) {
	rows, err := q.db.Query(ctx, listResellersWithAccount, arg.Search, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListResellersWithAccountRow{}
	for rows.Next() {
		var i ListResellersWithAccountRow
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.PhoneNumber,
			&i.Email,
			&i.ResellerID,
			&i.TotalStockReceived,
			&i.TotalValueReceived,
			&i.TotalSalesValue,
			&i.TotalPaid,
			&i.TotalCogs,
			&i.Balance,
			&i.CurrentStockUnits,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResellersWithAccountCount = `-- name: ListResellersWithAccountCount :one
SELECT COUNT(*) AS total_resellers
FROM users u
WHERE 
    role = 'staff' AND deleted = false
    AND (
        COALESCE($1, '') = '' 
        OR LOWER(name) LIKE $1
        OR LOWER(phone_number) LIKE $1
        OR LOWER(email) LIKE $1
    )
`

func (q *Queries) ListResellersWithAccountCount(ctx context.Context, search interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, listResellersWithAccountCount, search)
	var total_resellers int64
	err := row.Scan(&total_resellers)
	return total_resellers, err
}

const subtractResellerStockQuantity = `-- name: SubtractResellerStockQuantity :one
UPDATE reseller_stock
SET quantity = GREATEST(quantity - $3, 0)
WHERE reseller_id = $1 AND product_id = $2
RETURNING reseller_id, product_id, quantity, low_stock_threshold
`

type SubtractResellerStockQuantityParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
	Quantity   int64 `json:"quantity"`
}

func (q *Queries) SubtractResellerStockQuantity(ctx context.Context, arg SubtractResellerStockQuantityParams) (ResellerStock, error) {
	row := q.db.QueryRow(ctx, subtractResellerStockQuantity, arg.ResellerID, arg.ProductID, arg.Quantity)
	var i ResellerStock
	err := row.Scan(
		&i.ResellerID,
		&i.ProductID,
		&i.Quantity,
		&i.LowStockThreshold,
	)
	return i, err
}

const updateResellerAccount = `-- name: UpdateResellerAccount :one
UPDATE reseller_accounts
SET total_stock_received = coalesce($1, total_stock_received),
    total_value_received = coalesce($2, total_value_received),
    total_sales_value = coalesce($3, total_sales_value),
    total_paid = coalesce($4, total_paid),
    total_cogs = coalesce($5, total_cogs),
    balance = coalesce($6, balance)
WHERE reseller_id = $7
RETURNING reseller_id, total_stock_received, total_value_received, total_sales_value, total_paid, total_cogs, balance
`

type UpdateResellerAccountParams struct {
	TotalStockReceived pgtype.Int8    `json:"total_stock_received"`
	TotalValueReceived pgtype.Numeric `json:"total_value_received"`
	TotalSalesValue    pgtype.Numeric `json:"total_sales_value"`
	TotalPaid          pgtype.Numeric `json:"total_paid"`
	TotalCogs          pgtype.Numeric `json:"total_cogs"`
	Balance            pgtype.Numeric `json:"balance"`
	ResellerID         int64          `json:"reseller_id"`
}

func (q *Queries) UpdateResellerAccount(ctx context.Context, arg UpdateResellerAccountParams) (ResellerAccount, error) {
	row := q.db.QueryRow(ctx, updateResellerAccount,
		arg.TotalStockReceived,
		arg.TotalValueReceived,
		arg.TotalSalesValue,
		arg.TotalPaid,
		arg.TotalCogs,
		arg.Balance,
		arg.ResellerID,
	)
	var i ResellerAccount
	err := row.Scan(
		&i.ResellerID,
		&i.TotalStockReceived,
		&i.TotalValueReceived,
		&i.TotalSalesValue,
		&i.TotalPaid,
		&i.TotalCogs,
		&i.Balance,
	)
	return i, err
}

const updateResellerStockThreshold = `-- name: UpdateResellerStockThreshold :one
UPDATE reseller_stock
SET low_stock_threshold = $3
WHERE reseller_id = $1 AND product_id = $2
RETURNING reseller_id, product_id, quantity, low_stock_threshold
`

type UpdateResellerStockThresholdParams struct {
	ResellerID        int64 `json:"reseller_id"`
	ProductID         int64 `json:"product_id"`
	LowStockThreshold int32 `json:"low_stock_threshold"`
}

func (q *Queries) UpdateResellerStockThreshold(ctx context.Context, arg UpdateResellerStockThresholdParams) (ResellerStock, error) {
	row := q.db.QueryRow(ctx, updateResellerStockThreshold, arg.ResellerID, arg.ProductID, arg.LowStockThreshold)
	var i ResellerStock
	err := row.Scan(
		&i.ResellerID,
		&i.ProductID,
		&i.Quantity,
		&i.LowStockThreshold,
	)
	return i, err
}
