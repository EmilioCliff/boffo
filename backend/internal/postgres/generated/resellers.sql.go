// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: resellers.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addResellerStockQuantity = `-- name: AddResellerStockQuantity :one
UPDATE reseller_stock
SET quantity = quantity + $3
WHERE reseller_id = $1 AND product_id = $2
RETURNING reseller_id, product_id, quantity, low_stock_threshold
`

type AddResellerStockQuantityParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
	Quantity   int64 `json:"quantity"`
}

func (q *Queries) AddResellerStockQuantity(ctx context.Context, arg AddResellerStockQuantityParams) (ResellerStock, error) {
	row := q.db.QueryRow(ctx, addResellerStockQuantity, arg.ResellerID, arg.ProductID, arg.Quantity)
	var i ResellerStock
	err := row.Scan(
		&i.ResellerID,
		&i.ProductID,
		&i.Quantity,
		&i.LowStockThreshold,
	)
	return i, err
}

const checkResellerStockExists = `-- name: CheckResellerStockExists :one
SELECT EXISTS (
    SELECT 1 FROM reseller_stock
    WHERE reseller_id = $1 AND product_id = $2
)
`

type CheckResellerStockExistsParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
}

func (q *Queries) CheckResellerStockExists(ctx context.Context, arg CheckResellerStockExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkResellerStockExists, arg.ResellerID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createResellerAccount = `-- name: CreateResellerAccount :one
INSERT INTO reseller_accounts (reseller_id)
VALUES ($1)
RETURNING reseller_id, total_stock_received, total_value_received, total_sales_value, total_paid, total_cogs, balance
`

func (q *Queries) CreateResellerAccount(ctx context.Context, resellerID int64) (ResellerAccount, error) {
	row := q.db.QueryRow(ctx, createResellerAccount, resellerID)
	var i ResellerAccount
	err := row.Scan(
		&i.ResellerID,
		&i.TotalStockReceived,
		&i.TotalValueReceived,
		&i.TotalSalesValue,
		&i.TotalPaid,
		&i.TotalCogs,
		&i.Balance,
	)
	return i, err
}

const createResellerStock = `-- name: CreateResellerStock :one
INSERT INTO reseller_stock (reseller_id, product_id, quantity)
VALUES ($1, $2, $3)
RETURNING reseller_id, product_id, quantity, low_stock_threshold
`

type CreateResellerStockParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
	Quantity   int64 `json:"quantity"`
}

func (q *Queries) CreateResellerStock(ctx context.Context, arg CreateResellerStockParams) (ResellerStock, error) {
	row := q.db.QueryRow(ctx, createResellerStock, arg.ResellerID, arg.ProductID, arg.Quantity)
	var i ResellerStock
	err := row.Scan(
		&i.ResellerID,
		&i.ProductID,
		&i.Quantity,
		&i.LowStockThreshold,
	)
	return i, err
}

const getResellerAccount = `-- name: GetResellerAccount :one
SELECT reseller_id, total_stock_received, total_value_received, total_sales_value, total_paid, total_cogs, balance FROM reseller_accounts
WHERE reseller_id = $1
`

func (q *Queries) GetResellerAccount(ctx context.Context, resellerID int64) (ResellerAccount, error) {
	row := q.db.QueryRow(ctx, getResellerAccount, resellerID)
	var i ResellerAccount
	err := row.Scan(
		&i.ResellerID,
		&i.TotalStockReceived,
		&i.TotalValueReceived,
		&i.TotalSalesValue,
		&i.TotalPaid,
		&i.TotalCogs,
		&i.Balance,
	)
	return i, err
}

const listResellerStock = `-- name: ListResellerStock :many
SELECT 
    rs.reseller_id, rs.product_id, rs.quantity, rs.low_stock_threshold, 
    p.id AS product_id,
    p.name,
    p.category,
    p.unit,
    p.price,
    p.low_stock_threshold
FROM reseller_stock rs
JOIN products p ON p.id = rs.product_id
WHERE 
    (
        COALESCE($1, '') = '' 
        OR LOWER(p.name) LIKE $1
        OR LOWER(p.category) LIKE $1
    )
     AND (
        $2::boolean IS NULL
        OR ($2 = true AND rs.quantity > 0)
        OR ($2 = false AND rs.quantity = 0)
    )
    AND (
        $3::bigint IS NULL
        OR rs.reseller_id = $3::bigint
    )
    -- AND rs.reseller_id = sqlc.arg('reseller_id')
ORDER BY p.name
LIMIT $5 OFFSET $4
`

type ListResellerStockParams struct {
	Search     interface{} `json:"search"`
	InStock    pgtype.Bool `json:"in_stock"`
	ResellerID pgtype.Int8 `json:"reseller_id"`
	Offset     int32       `json:"offset"`
	Limit      int32       `json:"limit"`
}

type ListResellerStockRow struct {
	ResellerID          int64          `json:"reseller_id"`
	ProductID           int64          `json:"product_id"`
	Quantity            int64          `json:"quantity"`
	LowStockThreshold   int32          `json:"low_stock_threshold"`
	ProductID_2         int64          `json:"product_id_2"`
	Name                string         `json:"name"`
	Category            string         `json:"category"`
	Unit                string         `json:"unit"`
	Price               pgtype.Numeric `json:"price"`
	LowStockThreshold_2 int32          `json:"low_stock_threshold_2"`
}

func (q *Queries) ListResellerStock(ctx context.Context, arg ListResellerStockParams) ([]ListResellerStockRow, error) {
	rows, err := q.db.Query(ctx, listResellerStock,
		arg.Search,
		arg.InStock,
		arg.ResellerID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListResellerStockRow{}
	for rows.Next() {
		var i ListResellerStockRow
		if err := rows.Scan(
			&i.ResellerID,
			&i.ProductID,
			&i.Quantity,
			&i.LowStockThreshold,
			&i.ProductID_2,
			&i.Name,
			&i.Category,
			&i.Unit,
			&i.Price,
			&i.LowStockThreshold_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResellerStockCount = `-- name: ListResellerStockCount :one
SELECT COUNT(*) AS total_items
FROM reseller_stock rs
JOIN products p ON p.id = rs.product_id
WHERE 
    (
        COALESCE($1, '') = '' 
        OR LOWER(p.name) LIKE $1
        OR LOWER(p.category) LIKE $1
    )
     AND (
        $2::boolean IS NULL
        OR ($2 = true AND rs.quantity > 0)
        OR ($2 = false AND rs.quantity = 0)
    )
    AND (
        $3::bigint IS NULL
        OR rs.reseller_id = $3::bigint
    )
`

type ListResellerStockCountParams struct {
	Search     interface{} `json:"search"`
	InStock    pgtype.Bool `json:"in_stock"`
	ResellerID pgtype.Int8 `json:"reseller_id"`
}

func (q *Queries) ListResellerStockCount(ctx context.Context, arg ListResellerStockCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listResellerStockCount, arg.Search, arg.InStock, arg.ResellerID)
	var total_items int64
	err := row.Scan(&total_items)
	return total_items, err
}

const subtractResellerStockQuantity = `-- name: SubtractResellerStockQuantity :one
UPDATE reseller_stock
SET quantity = GREATEST(quantity - $3, 0)
WHERE reseller_id = $1 AND product_id = $2
RETURNING reseller_id, product_id, quantity, low_stock_threshold
`

type SubtractResellerStockQuantityParams struct {
	ResellerID int64 `json:"reseller_id"`
	ProductID  int64 `json:"product_id"`
	Quantity   int64 `json:"quantity"`
}

func (q *Queries) SubtractResellerStockQuantity(ctx context.Context, arg SubtractResellerStockQuantityParams) (ResellerStock, error) {
	row := q.db.QueryRow(ctx, subtractResellerStockQuantity, arg.ResellerID, arg.ProductID, arg.Quantity)
	var i ResellerStock
	err := row.Scan(
		&i.ResellerID,
		&i.ProductID,
		&i.Quantity,
		&i.LowStockThreshold,
	)
	return i, err
}

const updateResellerAccount = `-- name: UpdateResellerAccount :one
UPDATE reseller_accounts
SET total_stock_received = coalesce($1, total_stock_received),
    total_value_received = coalesce($2, total_value_received),
    total_sales_value = coalesce($3, total_sales_value),
    total_paid = coalesce($4, total_paid),
    total_cogs = coalesce($5, total_cogs),
    balance = coalesce($6, balance)
WHERE reseller_id = $7
RETURNING reseller_id, total_stock_received, total_value_received, total_sales_value, total_paid, total_cogs, balance
`

type UpdateResellerAccountParams struct {
	TotalStockReceived pgtype.Int8    `json:"total_stock_received"`
	TotalValueReceived pgtype.Numeric `json:"total_value_received"`
	TotalSalesValue    pgtype.Numeric `json:"total_sales_value"`
	TotalPaid          pgtype.Numeric `json:"total_paid"`
	TotalCogs          pgtype.Numeric `json:"total_cogs"`
	Balance            pgtype.Numeric `json:"balance"`
	ResellerID         int64          `json:"reseller_id"`
}

func (q *Queries) UpdateResellerAccount(ctx context.Context, arg UpdateResellerAccountParams) (ResellerAccount, error) {
	row := q.db.QueryRow(ctx, updateResellerAccount,
		arg.TotalStockReceived,
		arg.TotalValueReceived,
		arg.TotalSalesValue,
		arg.TotalPaid,
		arg.TotalCogs,
		arg.Balance,
		arg.ResellerID,
	)
	var i ResellerAccount
	err := row.Scan(
		&i.ResellerID,
		&i.TotalStockReceived,
		&i.TotalValueReceived,
		&i.TotalSalesValue,
		&i.TotalPaid,
		&i.TotalCogs,
		&i.Balance,
	)
	return i, err
}

const updateResellerStockThreshold = `-- name: UpdateResellerStockThreshold :one
UPDATE reseller_stock
SET low_stock_threshold = $3
WHERE reseller_id = $1 AND product_id = $2
RETURNING reseller_id, product_id, quantity, low_stock_threshold
`

type UpdateResellerStockThresholdParams struct {
	ResellerID        int64 `json:"reseller_id"`
	ProductID         int64 `json:"product_id"`
	LowStockThreshold int32 `json:"low_stock_threshold"`
}

func (q *Queries) UpdateResellerStockThreshold(ctx context.Context, arg UpdateResellerStockThresholdParams) (ResellerStock, error) {
	row := q.db.QueryRow(ctx, updateResellerStockThreshold, arg.ResellerID, arg.ProductID, arg.LowStockThreshold)
	var i ResellerStock
	err := row.Scan(
		&i.ResellerID,
		&i.ProductID,
		&i.Quantity,
		&i.LowStockThreshold,
	)
	return i, err
}
