// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reseller_sales.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createResellerSalesRecord = `-- name: CreateResellerSalesRecord :one
INSERT INTO reseller_sales (reseller_id, product_id, quantity, selling_price, date_sold)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, reseller_id, product_id, quantity, selling_price, total_amount, date_sold, created_at
`

type CreateResellerSalesRecordParams struct {
	ResellerID   int64          `json:"reseller_id"`
	ProductID    int64          `json:"product_id"`
	Quantity     int32          `json:"quantity"`
	SellingPrice pgtype.Numeric `json:"selling_price"`
	DateSold     time.Time      `json:"date_sold"`
}

func (q *Queries) CreateResellerSalesRecord(ctx context.Context, arg CreateResellerSalesRecordParams) (ResellerSale, error) {
	row := q.db.QueryRow(ctx, createResellerSalesRecord,
		arg.ResellerID,
		arg.ProductID,
		arg.Quantity,
		arg.SellingPrice,
		arg.DateSold,
	)
	var i ResellerSale
	err := row.Scan(
		&i.ID,
		&i.ResellerID,
		&i.ProductID,
		&i.Quantity,
		&i.SellingPrice,
		&i.TotalAmount,
		&i.DateSold,
		&i.CreatedAt,
	)
	return i, err
}

const listResellerSales = `-- name: ListResellerSales :many
SELECT rs.id, rs.reseller_id, rs.product_id, rs.quantity, rs.selling_price, rs.total_amount, rs.date_sold, rs.created_at, p.name AS product_name,
    p.unit AS product_unit,
    p.category AS product_category
FROM reseller_sales rs
JOIN products p ON p.id = rs.product_id
WHERE 
    (
        $1::bigint IS NULL
        OR rs.reseller_id = $1
    )
    AND (
        $2::bigint IS NULL
        OR rs.product_id = $2
    )
ORDER BY rs.date_sold DESC
LIMIT $4 OFFSET $3
`

type ListResellerSalesParams struct {
	ResellerID pgtype.Int8 `json:"reseller_id"`
	ProductID  pgtype.Int8 `json:"product_id"`
	Offset     int32       `json:"offset"`
	Limit      int32       `json:"limit"`
}

type ListResellerSalesRow struct {
	ID              int64          `json:"id"`
	ResellerID      int64          `json:"reseller_id"`
	ProductID       int64          `json:"product_id"`
	Quantity        int32          `json:"quantity"`
	SellingPrice    pgtype.Numeric `json:"selling_price"`
	TotalAmount     pgtype.Numeric `json:"total_amount"`
	DateSold        time.Time      `json:"date_sold"`
	CreatedAt       time.Time      `json:"created_at"`
	ProductName     string         `json:"product_name"`
	ProductUnit     string         `json:"product_unit"`
	ProductCategory string         `json:"product_category"`
}

func (q *Queries) ListResellerSales(ctx context.Context, arg ListResellerSalesParams) ([]ListResellerSalesRow, error) {
	rows, err := q.db.Query(ctx, listResellerSales,
		arg.ResellerID,
		arg.ProductID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListResellerSalesRow{}
	for rows.Next() {
		var i ListResellerSalesRow
		if err := rows.Scan(
			&i.ID,
			&i.ResellerID,
			&i.ProductID,
			&i.Quantity,
			&i.SellingPrice,
			&i.TotalAmount,
			&i.DateSold,
			&i.CreatedAt,
			&i.ProductName,
			&i.ProductUnit,
			&i.ProductCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResellerSalesCount = `-- name: ListResellerSalesCount :one
SELECT COUNT(*) AS total_sales
FROM reseller_sales rs
WHERE 
    (
        $1::bigint IS NULL
        OR rs.reseller_id = $1
    )
    AND (
        $2::bigint IS NULL
        OR rs.product_id = $2
    )
`

type ListResellerSalesCountParams struct {
	ResellerID pgtype.Int8 `json:"reseller_id"`
	ProductID  pgtype.Int8 `json:"product_id"`
}

func (q *Queries) ListResellerSalesCount(ctx context.Context, arg ListResellerSalesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listResellerSalesCount, arg.ResellerID, arg.ProductID)
	var total_sales int64
	err := row.Scan(&total_sales)
	return total_sales, err
}
